<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TECH X - 화상 회의</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #4a6cf7;
            --primary-hover: #3a5be8;
            --secondary-color: #6c757d;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-color: #e6e6e6;
            --background-color: #f4f7fc;
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: #333;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 2rem auto;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: white;
            padding: 1.2rem;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            margin-top: 80px;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--secondary-color);
            transition: var(--transition);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-button:hover {
            color: var(--primary-color);
            background-color: var(--light-color);
        }

        .header h1 {
            margin: 0;
            font-size: 1.6rem;
            font-weight: 600;
            color: #333;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            background-color: var(--light-color);
            padding: 0.5rem 1rem;
            border-radius: 50px;
        }

        .user-info i {
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .user-info .user-name {
            font-weight: 600;
        }

        .user-info .user-dept {
            color: var(--secondary-color);
            font-size: 0.85rem;
        }

        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .video-box {
            position: relative;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            box-shadow: var(--card-shadow);
            transition: var(--transition);
        }

        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-box .user-name {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .video-box .video-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
        }

        .video-box.local-video {
            border: 3px solid var(--primary-color);
        }

        .room-controls {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            margin-bottom: 1.5rem;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: var(--secondary-color);
            color: white;
            font-size: 1.3rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .control-btn.mute {
            background-color: var(--danger-color);
        }

        .control-btn.end-call {
            background-color: var(--danger-color);
        }

        .control-btn.mute:hover,
        .control-btn.end-call:hover {
            background-color: #c0392b;
        }

        .room-info, .participants {
            background-color: white;
            padding: 1.8rem;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            margin-bottom: 1.5rem;
        }

        .room-info h2, .participants h2 {
            margin-top: 0;
            margin-bottom: 1.2rem;
            font-size: 1.4rem;
            font-weight: 600;
            color: #333;
        }

        .participants-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .participants-list li {
            padding: 0.8rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
        }

        .participants-list li:last-child {
            border-bottom: none;
        }

        .participants-list li .status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--success-color);
            margin-right: 0.8rem;
            box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.2);
        }

        .participants-list li .status.offline {
            background-color: var(--secondary-color);
        }

        /* 로딩 스피너 */
        .loading-spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 토스트 메시지 */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
        }

        .toast {
            background-color: white;
            min-width: 250px;
            max-width: 350px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            margin-bottom: 10px;
            animation: toastFadeIn 0.3s;
            overflow: hidden;
        }

        .toast-header {
            padding: 0.8rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-color);
        }

        .toast-title {
            font-weight: 600;
            margin-right: auto;
        }

        .toast-body {
            padding: 0.8rem 1rem;
        }

        .toast-success .toast-header {
            background-color: var(--success-color);
            color: white;
        }

        .toast-warning .toast-header {
            background-color: #f39c12;
            color: white;
        }

        .toast-error .toast-header {
            background-color: var(--danger-color);
            color: white;
        }

        .toast-info .toast-header {
            background-color: var(--primary-color);
            color: white;
        }

        @keyframes toastFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 디바이스 선택 메뉴 */
        .device-menu {
            position: absolute;
            top: 120%;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 1rem;
            min-width: 200px;
            z-index: 100;
            display: none;
        }

        .device-menu.show {
            display: block;
        }

        .device-menu h3 {
            margin-top: 0;
            margin-bottom: 0.8rem;
            font-size: 1rem;
        }

        .device-menu select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .device-menu button {
            width: 100%;
        }

        /* 상대적 위치 설정 */
        .control-wrapper {
            position: relative;
        }

        /* 반응형 조정 */
        @media (max-width: 768px) {
            .container {
                width: 95%;
                margin: 1rem auto;
            }

            .video-container {
                grid-template-columns: 1fr;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.1rem;
            }

            .room-controls {
                gap: 0.8rem;
            }
        }

        /* 숨김 클래스 */
        .hidden {
            display: none;
        }
    </style>
</head>
<!-- 헤더 에셋 포함 -->
<th:block th:replace="fragments/header :: headerAssets"></th:block>

<body>
<!-- 헤더 포함 -->
<div th:replace="fragments/header :: header"></div>

<div class="container">
    <div class="header">
        <div class="header-left">
            <button id="backButton" class="back-button">
                <i class="fas fa-arrow-left"></i>
            </button>
            <h1>TECH X 화상 회의</h1>
        </div>
        <div class="user-info">
            <i class="fas fa-user-circle"></i>
            <span class="user-name" th:text="${employee.name}">사용자 이름</span>
            <span class="user-dept" th:text="${employee.departmentName}">부서명</span>
        </div>
    </div>

    <!-- 회의 정보 -->
    <div id="room-info" class="room-info">
        <h2>회의 정보</h2>
        <p>방 ID: <strong id="current-room-id"></strong></p>
        <p>회의명: <strong id="current-room-name"></strong></p>
    </div>

    <!-- 화상 채팅 영역 -->
    <div id="video-container" class="video-container">
        <!-- 비디오 요소들이 여기에 동적으로 추가됩니다 -->
    </div>

    <!-- 참가자 목록 -->
    <div class="participants">
        <h2>참가자</h2>
        <ul class="participants-list" id="participants-list">
            <!-- 참가자 목록이 여기에 동적으로 추가됩니다 -->
        </ul>
    </div>

    <!-- 회의실 제어 버튼 -->
    <div class="room-controls">
        <div class="control-wrapper">
            <button id="toggleAudio" class="control-btn">
                <i class="fas fa-microphone"></i>
            </button>
            <div id="audioDeviceMenu" class="device-menu">
                <h3>마이크 선택</h3>
                <select id="audioDeviceSelect"></select>
                <button id="applyAudioDevice" class="btn btn-primary">적용</button>
            </div>
        </div>

        <div class="control-wrapper">
            <button id="toggleVideo" class="control-btn">
                <i class="fas fa-video"></i>
            </button>
            <div id="videoDeviceMenu" class="device-menu">
                <h3>카메라 선택</h3>
                <select id="videoDeviceSelect"></select>
                <button id="applyVideoDevice" class="btn btn-primary">적용</button>
            </div>
        </div>

        <button id="shareScreen" class="control-btn">
            <i class="fas fa-desktop"></i>
        </button>

        <button id="leaveRoom" class="control-btn end-call">
            <i class="fas fa-phone-slash"></i>
        </button>
    </div>
</div>

<!-- 로딩 스피너 -->
<div id="loading-spinner" class="loading-spinner hidden">
    <div class="spinner"></div>
</div>

<!-- 토스트 메시지 컨테이너 -->
<div id="toast-container" class="toast-container"></div>

<!-- JavaScript 라이브러리 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.0/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
<script th:inline="javascript">
    // 직원 정보 가져오기 (Thymeleaf에서 전달)
    const employeeInfo = {
        empNum: /*[[${employee.empNum}]]*/ '',
        empName: /*[[${employee.name}]]*/ '',
        deptName: /*[[${employee.departmentName}]]*/ ''
    };

    // URL에서 roomId 파라미터 가져오기
    const urlParams = new URLSearchParams(window.location.search);
    const roomIdFromUrl = urlParams.get('roomId');

    // 사용자 정보 및 상태 관리
    const state = {
        username: employeeInfo.empName,
        empNum: employeeInfo.empNum,
        deptName: employeeInfo.deptName,
        roomId: roomIdFromUrl || sessionStorage.getItem('roomId') || '',
        roomName: sessionStorage.getItem('roomName') || '',
        roomPassword: sessionStorage.getItem('roomPassword') || '',
        localStream: null,
        screenStream: null,
        peerConnections: {}, // 다른 참가자와의 연결을 저장
        participants: {}, // 참가자 상태 저장
        participantsMap: new Map(), // 참가자 정보 맵
        isMuted: false,
        isVideoOff: false,
        isScreenSharing: false,
        deviceSettings: {
            audioInput: null,
            videoInput: null
        },
        connectionRetries: {}, // 참가자별 연결 재시도 횟수
        maxConnectionRetries: 3, // 최대 연결 재시도 횟수
        isLeaving: false // 나가기 처리 중인지 여부
    };

    // WebRTC 설정
    const peerConnectionConfig = {
        'iceServers': [
            {'urls': 'stun:stun.stunprotocol.org:3478'},
            {'urls': 'stun:stun.l.google.com:19302'},
            {'urls': 'stun:stun1.l.google.com:19302'},
            {'urls': 'stun:stun2.l.google.com:19302'},
            {'urls': 'stun:stun3.l.google.com:19302'},
            {'urls': 'stun:stun4.l.google.com:19302'}
        ],
        iceCandidatePoolSize: 10
    };

    // DOM 요소
    const backButton = document.getElementById('backButton');
    const videoContainer = document.getElementById('video-container');
    const participantsList = document.getElementById('participants-list');
    const toggleAudioBtn = document.getElementById('toggleAudio');
    const toggleVideoBtn = document.getElementById('toggleVideo');
    const shareScreenBtn = document.getElementById('shareScreen');
    const leaveRoomBtn = document.getElementById('leaveRoom');
    const roomInfo = document.getElementById('room-info');
    const currentRoomId = document.getElementById('current-room-id');
    const currentRoomName = document.getElementById('current-room-name');
    const loadingSpinner = document.getElementById('loading-spinner');

    // 디바이스 선택 메뉴
    const audioDeviceMenu = document.getElementById('audioDeviceMenu');
    const videoDeviceMenu = document.getElementById('videoDeviceMenu');
    const audioDeviceSelect = document.getElementById('audioDeviceSelect');
    const videoDeviceSelect = document.getElementById('videoDeviceSelect');
    const applyAudioDeviceBtn = document.getElementById('applyAudioDevice');
    const applyVideoDeviceBtn = document.getElementById('applyVideoDevice');

    // WebSocket 연결
    let socket;
    let stompClient;

    // 하트비트 관련 변수
    let heartbeatInterval = null;
    const HEARTBEAT_INTERVAL = 15000; // 15초마다 하트비트 전송
    const HEARTBEAT_TIMEOUT = 5000; // 하트비트 응답 대기 시간 (5초)
    let lastHeartbeatResponse = Date.now(); // 마지막 하트비트 응답 시간
    let heartbeatTimeoutId = null; // 하트비트 타임아웃 ID

    // 페이지 로드 시 초기화
    window.addEventListener('DOMContentLoaded', initializeRoom);

    // 뒤로가기 버튼 처리
    backButton.addEventListener('click', () => {
        if (confirm('회의에서 나가시겠습니까?')) {
            leaveRoom();
        }
    });

    // 로딩 표시/숨김 함수
    function showLoading() {
        loadingSpinner.classList.remove('hidden');
    }

    function hideLoading() {
        loadingSpinner.classList.add('hidden');
    }

    // 토스트 메시지 표시 함수
    function showToast(type, title, message, duration = 5000) {
        const toastContainer = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;

        toast.innerHTML = `
            <div class="toast-header">
                <span class="toast-title">${title}</span>
                <button type="button" class="close-toast">&times;</button>
            </div>
            <div class="toast-body">${message}</div>
        `;

        toastContainer.appendChild(toast);

        // 닫기 버튼 이벤트
        toast.querySelector('.close-toast').addEventListener('click', () => {
            toast.remove();
        });

        // 자동 닫기
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(-20px)';
            toast.style.transition = 'all 0.3s ease';

            setTimeout(() => {
                toast.remove();
            }, 300);
        }, duration);
    }

    // 룸 초기화 함수
    async function initializeRoom() {
        try {
            showLoading();

            // 방 정보가 없으면 로비로 리다이렉트
            if (!state.roomId) {
                alert('유효한 회의실 정보가 없습니다.');
                window.location.href = '/videoconf-lobby';
                return;
            }

            // 회의 정보 표시
            currentRoomId.textContent = state.roomId;
            currentRoomName.textContent = state.roomName || state.roomId;

            // 미디어 장치 초기화
            await initMediaDevices();

            // WebSocket 연결
            connectToWebSocket();

            // 하트비트 시작
            startHeartbeat();

            // 화면 이벤트 리스너 등록
            registerEventListeners();

            hideLoading();
        } catch (error) {
            console.error('회의실 초기화 오류:', error);
            showToast('error', '초기화 오류', '회의실 초기화 중 오류가 발생했습니다.');
            hideLoading();
        }
    }

    // 미디어 장치 초기화 함수
    async function initMediaDevices() {
        try {
            // 사용 가능한 미디어 장치 확인
            const devices = await navigator.mediaDevices.enumerateDevices();
            const hasCamera = devices.some(device => device.kind === 'videoinput');
            const hasMicrophone = devices.some(device => device.kind === 'audioinput');

            // 미디어 제약 조건 설정
            const constraints = {
                audio: hasMicrophone,
                video: hasCamera ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } : false
            };

            // 미디어 요청
            try {
                state.localStream = await navigator.mediaDevices.getUserMedia(constraints);

                // 로컬 비디오 요소 추가
                addVideoStream(state.username, state.localStream, true);

                // 장치 목록 업데이트
                updateDeviceLists();
            } catch (mediaError) {
                console.error('미디어 접근 오류:', mediaError);

                let errorMessage = '카메라/마이크 접근 오류';
                if (mediaError.name === 'NotAllowedError') {
                    errorMessage = '카메라/마이크 접근 권한이 거부되었습니다.';
                } else if (mediaError.name === 'NotFoundError') {
                    errorMessage = '카메라/마이크를 찾을 수 없습니다.';
                } else if (mediaError.name === 'NotReadableError') {
                    errorMessage = '카메라/마이크가 다른 앱에 의해 사용 중입니다.';
                }

                showToast('warning', '미디어 오류', errorMessage);

                // 더미 스트림으로 진행
                createDummyStream();
            }
        } catch (error) {
            console.error('미디어 장치 초기화 오류:', error);

            // 더미 스트림으로 진행
            createDummyStream();
        }
    }

    // 더미 스트림 생성 (카메라/마이크 없는 경우)
    function createDummyStream() {
        const canvas = Object.assign(document.createElement('canvas'), { width: 640, height: 480 });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#444444';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 사용자 이름 표시
        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(state.username, canvas.width/2, canvas.height/2);
        ctx.fillText('(카메라/마이크 없음)', canvas.width/2, canvas.height/2 + 30);

        // 더미 스트림 생성
        state.localStream = canvas.captureStream(1); // 1fps

        // 로컬 비디오 요소 추가
        addVideoStream(state.username, state.localStream, true);
    }

    // 장치 목록 업데이트
    async function updateDeviceLists() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();

            // 오디오 장치 목록
            const audioInputs = devices.filter(device => device.kind === 'audioinput');
            audioDeviceSelect.innerHTML = '';

            audioInputs.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `마이크 ${audioDeviceSelect.length + 1}`;
                audioDeviceSelect.appendChild(option);
            });

            // 비디오 장치 목록
            const videoInputs = devices.filter(device => device.kind === 'videoinput');
            videoDeviceSelect.innerHTML = '';

            videoInputs.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `카메라 ${videoDeviceSelect.length + 1}`;
                videoDeviceSelect.appendChild(option);
            });
        } catch (error) {
            console.error('장치 목록 업데이트 오류:', error);
        }
    }

    // 이벤트 리스너 등록
    function registerEventListeners() {
        // 오디오 토글 버튼
        toggleAudioBtn.addEventListener('click', (event) => {
            if (event.target === toggleAudioBtn) {
                toggleAudio();
            }
        });

        toggleAudioBtn.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            toggleDeviceMenu(audioDeviceMenu);
        });

        // 비디오 토글 버튼
        toggleVideoBtn.addEventListener('click', (event) => {
            if (event.target === toggleVideoBtn) {
                toggleVideo();
            }
        });

        toggleVideoBtn.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            toggleDeviceMenu(videoDeviceMenu);
        });

        // 화면 공유 버튼
        shareScreenBtn.addEventListener('click', toggleScreenSharing);

        // 나가기 버튼
        leaveRoomBtn.addEventListener('click', () => {
            if (confirm('정말 회의에서 나가시겠습니까?')) {
                leaveRoom();
            }
        });

        // 디바이스 적용 버튼
        applyAudioDeviceBtn.addEventListener('click', () => {
            changeAudioDevice(audioDeviceSelect.value);
            audioDeviceMenu.classList.remove('show');
        });

        applyVideoDeviceBtn.addEventListener('click', () => {
            changeVideoDevice(videoDeviceSelect.value);
            videoDeviceMenu.classList.remove('show');
        });

        // 페이지 가시성 변경 이벤트
        document.addEventListener('visibilitychange', handleVisibilityChange);

        // 페이지 언로드 이벤트
        window.addEventListener('beforeunload', handlePageUnload);
    }

    // 디바이스 메뉴 토글
    function toggleDeviceMenu(menu) {
        if (menu.classList.contains('show')) {
            menu.classList.remove('show');
        } else {
            // 다른 메뉴 닫기
            document.querySelectorAll('.device-menu').forEach(m => {
                m.classList.remove('show');
            });
            menu.classList.add('show');
        }
    }

    // 오디오 장치 변경
    async function changeAudioDevice(deviceId) {
        try {
            if (!deviceId) return;

            // 새 오디오 스트림 생성
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: { deviceId: { exact: deviceId } },
                video: false
            });

            // 기존 오디오 트랙 정지
            state.localStream.getAudioTracks().forEach(track => track.stop());

            // 새 오디오 트랙 추가
            const newAudioTrack = stream.getAudioTracks()[0];

            if (newAudioTrack) {
                // 로컬 스트림에 새 트랙 추가
                state.localStream.removeTrack(state.localStream.getAudioTracks()[0]);
                state.localStream.addTrack(newAudioTrack);

                // 상태에 맞게 음소거 적용
                newAudioTrack.enabled = !state.isMuted;

                // 모든 피어 연결에 새 트랙 추가
                Object.values(state.peerConnections).forEach(pcWrapper => {
                    if (pcWrapper.connection) {
                        const senders = pcWrapper.connection.getSenders();
                        const audioSender = senders.find(sender =>
                            sender.track && sender.track.kind === 'audio'
                        );

                        if (audioSender) {
                            audioSender.replaceTrack(newAudioTrack);
                        }
                    }
                });

                showToast('success', '장치 변경', '마이크가 변경되었습니다.');
            }
        } catch (error) {
            console.error('오디오 장치 변경 오류:', error);
            showToast('error', '장치 변경 오류', '마이크 변경 중 오류가 발생했습니다.');
        }
    }

    // 비디오 장치 변경
    async function changeVideoDevice(deviceId) {
        try {
            if (!deviceId) return;

            // 새 비디오 스트림 생성
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: { deviceId: { exact: deviceId } }
            });

            // 기존 비디오 트랙 정지
            state.localStream.getVideoTracks().forEach(track => track.stop());

            // 새 비디오 트랙 추가
            const newVideoTrack = stream.getVideoTracks()[0];

            if (newVideoTrack) {
                // 로컬 스트림에 새 트랙 추가
                state.localStream.removeTrack(state.localStream.getVideoTracks()[0]);
                state.localStream.addTrack(newVideoTrack);

                // 상태에 맞게 비디오 설정
                newVideoTrack.enabled = !state.isVideoOff;

                // 모든 피어 연결에 새 트랙 추가
                Object.values(state.peerConnections).forEach(pcWrapper => {
                    if (pcWrapper.connection) {
                        const senders = pcWrapper.connection.getSenders();
                        const videoSender = senders.find(sender =>
                            sender.track && sender.track.kind === 'video'
                        );

                        if (videoSender) {
                            videoSender.replaceTrack(newVideoTrack);
                        }
                    }
                });

                // 로컬 비디오 업데이트
                const localVideo = document.getElementById(`video-${state.username}`);
                if (localVideo) {
                    localVideo.srcObject = state.localStream;
                }

                showToast('success', '장치 변경', '카메라가 변경되었습니다.');
            }
        } catch (error) {
            console.error('비디오 장치 변경 오류:', error);
            showToast('error', '장치 변경 오류', '카메라 변경 중 오류가 발생했습니다.');
        }
    }

    // 페이지 가시성 변경 처리
    function handleVisibilityChange() {
        if (document.visibilityState === 'hidden') {
            console.log("페이지가 백그라운드로 전환되었습니다.");

            // 하트비트 간격 늘리기
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL * 2);
            }
        } else if (document.visibilityState === 'visible' && state.roomId) {
            console.log("페이지가 다시 활성화되었습니다.");

            // 하트비트 정상 간격으로 복원
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
            }

            // 방 상태 확인
            fetch(`/api/videoconf/check-room-validity?roomId=${state.roomId}`)
                .then(response => response.json())
                .then(result => {
                    if (!result.valid) {
                        console.log("방이 더 이상 유효하지 않습니다.");
                        showToast('warning', '회의 종료', "회의가 종료되었습니다.");
                        leaveRoom();
                    }
                })
                .catch(error => {
                    console.error("방 상태 확인 중 오류:", error);
                });
        }
    }

    // 페이지 언로드 처리
    function handlePageUnload(event) {
        // 하트비트 중지
        stopHeartbeat();

        if (state.roomId && !state.isLeaving) {
            // 방 나가기 API 호출
            navigator.sendBeacon(`/api/videoconf/leave-room?roomId=${state.roomId}&empNum=${state.empNum}`);

            // 리소스 정리
            clearResources();
        }
    }

    // 하트비트 시작
    function startHeartbeat() {
        // 기존 하트비트 중지
        stopHeartbeat();

        // 하트비트 시작
        lastHeartbeatResponse = Date.now();
        sendHeartbeat(); // 즉시 첫 하트비트 전송
        heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
        console.log("하트비트 시작됨");
    }

    // 하트비트 중지
    function stopHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;

            // 타임아웃 타이머도 정리
            if (heartbeatTimeoutId) {
                clearTimeout(heartbeatTimeoutId);
                heartbeatTimeoutId = null;
            }
            console.log("하트비트 중지됨");
        }
    }

    // 하트비트 전송
    function sendHeartbeat() {
        if (!state.roomId || !state.empNum) {
            console.log("방 ID 또는 사원 번호가 없어 하트비트를 보낼 수 없습니다.");
            stopHeartbeat();
            return;
        }

        // 마지막 하트비트 응답 시간 확인
        const timeSinceLastResponse = Date.now() - lastHeartbeatResponse;

        // 응답이 오지 않은 경우 (타임아웃)
        if (timeSinceLastResponse > HEARTBEAT_INTERVAL * 2) {
            console.warn(`하트비트 응답 없음 (${Math.round(timeSinceLastResponse / 1000)}초 경과)`);

            // 서버 상태 확인
            fetch(`/api/videoconf/check-room-validity?roomId=${state.roomId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('방 유효성 확인 실패');
                    }
                    return response.json();
                })
                .then(result => {
                    if (!result.valid) {
                        console.log("방이 더 이상 유효하지 않습니다.");
                        showToast('warning', '회의 종료', "회의가 종료되었습니다.");
                        leaveRoom();
                    } else {
                        // 방은 유효하지만 WebSocket이 끊어진 경우 재연결
                        if (!stompClient || !stompClient.connected) {
                            console.log("WebSocket 연결이 끊어졌습니다. 재연결 시도...");
                            showToast('warning', '연결 재시도 중', "서버와의 연결이 끊어졌습니다. 재연결 중...");
                            connectToWebSocket();
                        }
                    }
                })
                .catch(error => {
                    console.error("방 상태 확인 중 오류:", error);
                });
        }

        // WebSocket 메시지 전송 (우선)
        if (stompClient && stompClient.connected) {
            try {
                sendMessage({
                    from: state.username,
                    empNum: state.empNum,
                    type: 'heartbeat',
                    roomId: state.roomId
                });
            } catch (e) {
                console.warn('WebSocket 하트비트 전송 오류:', e);
                // WebSocket 실패시 HTTP로 대체
                sendHeartbeatHttp();
            }
        } else {
            // HTTP API 호출 (백업)
            sendHeartbeatHttp();
        }

        // 타임아웃 설정
        if (heartbeatTimeoutId) {
            clearTimeout(heartbeatTimeoutId);
        }

        heartbeatTimeoutId = setTimeout(() => {
            console.warn("하트비트 응답 타임아웃");
        }, HEARTBEAT_TIMEOUT);
    }

    // HTTP API를 통한 하트비트 전송
    function sendHeartbeatHttp() {
        fetch('/api/videoconf/heartbeat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                roomId: state.roomId,
                empNum: state.empNum
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('하트비트 응답 오류');
                }
                return response.json();
            })
            .then(data => {
                // 하트비트 응답 시간 업데이트
                lastHeartbeatResponse = Date.now();

                if (!data.roomActive) {
                    console.log("방이 더 이상 활성화되지 않았습니다. 연결을 종료합니다.");
                    showToast('warning', '회의 종료', "회의가 종료되었습니다.");
                    leaveRoom();
                    return;
                }
            })
            .catch(error => {
                console.error("하트비트 전송 중 오류:", error);
            });
    }

    // WebSocket 연결 함수
    function connectToWebSocket() {
        try {
            socket = new SockJS('/ws-videochat');
            stompClient = Stomp.over(socket);

            // 디버그 로그 비활성화
            stompClient.debug = null;

            // 웹소켓 연결 종료 이벤트 핸들러
            socket.onclose = function(event) {
                console.log('WebSocket 연결이 종료되었습니다.', event);

                // 의도적인 연결 종료가 아니고, 아직 방에 참가 중인 경우에만 재연결 시도
                if (!isIntentionalDisconnect && state.roomId && !state.isLeaving) {
                    // 재연결 시도
                    wsReconnectAttempts++;
                    if (wsReconnectAttempts < maxReconnectAttempts) {
                        console.log(`WebSocket 재연결 시도 (${wsReconnectAttempts}/${maxReconnectAttempts})...`);

                        showToast('warning', '연결 재시도 중',
                            `서버와의 연결이 끊어졌습니다. 재연결 중... (${wsReconnectAttempts}/${maxReconnectAttempts})`);

                        // 서버에 방이 여전히 유효한지 확인
                        fetch(`/api/videoconf/check-room-validity?roomId=${state.roomId}`)
                            .then(response => response.json())
                            .then(result => {
                                if (result.valid) {
                                    // 1초 후 재연결 시도
                                    setTimeout(connectToWebSocket, 1000);
                                } else {
                                    // 방이 더 이상 유효하지 않으면 퇴장 처리
                                    showToast('warning', '회의 종료', '회의가 종료되었습니다.');
                                    leaveRoom();
                                }
                            })
                            .catch(error => {
                                console.error('방 유효성 확인 오류:', error);
                                // 오류 발생해도 재연결 시도
                                setTimeout(connectToWebSocket, 1000);
                            });
                    } else {
                        console.error('최대 재연결 시도 횟수를 초과했습니다.');
                        showToast('error', '연결 실패', '서버와의 연결을 복구할 수 없습니다. 페이지를 새로고침해주세요.');
                    }
                } else {
                    // 의도적인 연결 종료인 경우 플래그 초기화
                    isIntentionalDisconnect = false;
                }
            };

            // 연결 성공/실패 콜백
            stompClient.connect(
                {
                    // 헤더에 세션 식별 정보 추가
                    'username': state.username,
                    'empNum': state.empNum,
                    'roomId': state.roomId
                },
                onConnected,
                onError
            );

        } catch (error) {
            console.error('WebSocket 연결 시도 중 오류:', error);
            showToast('error', '연결 오류', '서버에 연결할 수 없습니다. 네트워크 연결을 확인해주세요.');
        }
    }

    // 연결 종료 함수
    function disconnectWebSocket() {
        if (stompClient && stompClient.connected) {
            isIntentionalDisconnect = true;  // 의도적인 연결 종료 표시
            try {
                stompClient.disconnect();
            } catch (e) {
                console.warn('WebSocket 연결 종료 중 오류:', e);
            }
        }
        stompClient = null;
        socket = null;
    }

    // WebSocket 연결 성공 시 콜백
    function onConnected() {
        console.log("WebSocket 연결 성공");
        wsReconnectAttempts = 0;

        // 일반 메시지 구독
        stompClient.subscribe('/topic/videochat', onMessageReceived);

        // 참가자 목록 요청
        fetch(`/api/videoconf/participants?roomId=${state.roomId}`)
            .then(response => response.json())
            .then(participants => {
                console.log("참가자 목록:", participants);

                // 참가자 목록 초기화
                updateParticipantsList(participants);

                // 기존 참가자들과 연결 설정
                participants.forEach(participant => {
                    if (participant.empNum !== state.empNum) {
                        // 새 커넥션 생성 및 오퍼 전송
                        initConnectionWithExistingParticipant(participant);
                    }
                });

                // 방 참가 메시지 전송
                sendMessage({
                    from: state.username,
                    empNum: state.empNum,
                    deptName: state.deptName,
                    type: 'join',
                    roomId: state.roomId
                });
            })
            .catch(error => {
                console.error("참가자 목록 로딩 오류:", error);
                showToast('error', '참가자 로드 오류', '참가자 목록을 불러올 수 없습니다.');
            });
    }

    // 참가자 목록 업데이트 함수
    function updateParticipantsList(participants) {
        // 참가자 목록 UI 초기화
        participantsList.innerHTML = '';
        state.participantsMap.clear();

        // 자신을 목록에 추가
        const currentUser = participants.find(p => p.empNum === state.empNum);
        if (currentUser) {
            addParticipant(currentUser.name, true, currentUser.deptName);
            state.participantsMap.set(currentUser.empNum, currentUser);
        } else {
            addParticipant(state.username, true, state.deptName);
            state.participantsMap.set(state.empNum, {
                empNum: state.empNum,
                name: state.username,
                deptName: state.deptName,
                isActive: true
            });
        }

        // 다른 참가자들 추가
        participants.forEach(participant => {
            if (participant.empNum !== state.empNum) {
                addParticipant(participant.name, false, participant.deptName);
                state.participantsMap.set(participant.empNum, participant);
            }
        });
    }

    // 기존 참가자와 연결 초기화
    function initConnectionWithExistingParticipant(participant) {
        const username = participant.name;
        console.log(`기존 참가자와 연결 초기화: ${username}`);

        // 이미 연결이 있으면 중단
        if (state.peerConnections[username]) {
            console.log(`${username}와 이미 연결되어 있습니다.`);
            return;
        }

        // 연결 생성
        const pcWrapper = createPeerConnection(username);
        if (!pcWrapper) return;

        const peerConnection = pcWrapper.connection;

        // 로컬 스트림 추가
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => {
                try {
                    peerConnection.addTrack(track, state.localStream);
                } catch (e) {
                    console.error(`트랙 추가 오류 (${username}):`, e);
                }
            });
        }

        // Offer 생성 및 전송
        peerConnection.createOffer()
            .then(offer => peerConnection.setLocalDescription(offer))
            .then(() => {
                sendMessage({
                    from: state.username,
                    empNum: state.empNum,
                    deptName: state.deptName,
                    type: 'offer',
                    payload: peerConnection.localDescription,
                    roomId: state.roomId,
                    to: username
                });
            })
            .catch(error => console.error('Offer 생성 오류:', error));
    }

    // WebSocket 메시지 전송 함수
    function sendMessage(message) {
        if (!stompClient || !stompClient.connected) {
            console.warn('WebSocket이 연결되어 있지 않아 메시지를 보낼 수 없습니다.');
            return;
        }

        try {
            stompClient.send('/app/videochat.sendMessage', {}, JSON.stringify(message));
        } catch (error) {
            console.error('메시지 전송 오류:', error);
        }
    }

    // WebSocket 연결 오류 콜백
    function onError(error) {
        console.error('WebSocket 연결 오류:', error);
        showToast('error', '연결 오류', '서버 연결에 실패했습니다. 페이지를 새로고침해주세요.');
    }

    // WebSocket 메시지 수신 처리
    function onMessageReceived(payload) {
        try {
            const message = JSON.parse(payload.body);
            console.log("메시지 수신:", message);

            // 현재 방 ID와 메시지의 방 ID 검증
            const messageRoomId = message.roomId || '';
            if (messageRoomId !== state.roomId) {
                return;
            }

            // 새로 추가: 참가자 목록 업데이트 처리
            if (message.type === 'participants-update') {
                if (message.payload && Array.isArray(message.payload)) {
                    updateParticipantsList(message.payload);
                    return;
                }
            }

            // 하트비트 응답 처리
            if (message.type === 'heartbeat-response') {
                lastHeartbeatResponse = Date.now();
                if (heartbeatTimeoutId) {
                    clearTimeout(heartbeatTimeoutId);
                    heartbeatTimeoutId = null;
                }
                return;
            }

            switch (message.type) {
                case 'join':
                    if (message.empNum !== state.empNum) {
                        console.log("입장 메시지 수신:", message.from);

                        // 참가자 목록에 없는 경우 새로 추가
                        if (!state.participantsMap.has(message.empNum)) {
                            addParticipant(message.from, false, message.deptName);
                            state.participantsMap.set(message.empNum, {
                                empNum: message.empNum,
                                name: message.from,
                                deptName: message.deptName,
                                isActive: true
                            });
                        }

                        handleNewUser(message.from, message.empNum, message.deptName);
                    }
                    break;

                case 'offer':
                    console.log("Offer 메시지 수신:", message.from);
                    handleOffer(message.from, message.payload);
                    break;

                case 'answer':
                    console.log("Answer 메시지 수신:", message.from);
                    handleAnswer(message.from, message.payload);
                    break;

                case 'ice':
                    console.log("ICE 후보 메시지 수신:", message.from);
                    handleIceCandidate(message.from, message.payload);
                    break;

                case 'leave':
                    console.log("퇴장 메시지 수신:", message.from);
                    handleUserLeft(message.from, message.empNum);
                    break;
            }
        } catch (error) {
            console.error("메시지 처리 중 오류:", error);
        }
    }

    // 신규 사용자 처리 함수
    function handleNewUser(username, empNum, deptName) {
        // 이미 참가자 목록에 있는 경우 무시
        if (state.participants[username]) {
            console.log(`${username}은 이미 참가자 목록에 있습니다.`);
            return;
        }

        console.log(`새 사용자 ${username}(${deptName})가 참가했습니다.`);

        // 참가자 목록에 추가
        addParticipant(username, false, deptName);

        // 새 PeerConnection 생성
        const pcWrapper = createPeerConnection(username);
        if (!pcWrapper) return;

        const peerConnection = pcWrapper.connection;

        // 로컬 스트림 추가
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => {
                console.log(`${username}와의 연결에 로컬 트랙 추가: ${track.kind}`);
                peerConnection.addTrack(track, state.localStream);
            });
        } else {
            console.error("로컬 스트림이 없습니다. 미디어 접근 권한을 확인하세요.");
            return;
        }

        // Offer SDP 생성 및 전송
        peerConnection.createOffer()
            .then(offer => {
                console.log(`${username}에게 보낼 Offer 생성 완료`);
                return peerConnection.setLocalDescription(offer);
            })
            .then(() => {
                console.log(`${username}에게 Offer 전송`);
                sendMessage({
                    from: state.username,
                    empNum: state.empNum,
                    deptName: state.deptName,
                    type: 'offer',
                    payload: peerConnection.localDescription,
                    roomId: state.roomId,
                    to: username
                });
            })
            .catch(error => console.error('Offer 생성 오류:', error));
    }

    // Offer SDP 처리 함수
    function handleOffer(username, offer) {
        if (username === state.username) return; // 자기 자신이면 무시

        console.log(`${username}로부터 Offer를 받았습니다.`);

        // PeerConnection 생성
        const pcWrapper = createPeerConnection(username);
        if (!pcWrapper) return;

        const peerConnection = pcWrapper.connection;

        // 원격 SDP 설정
        pcWrapper.setRemoteDescription(offer)
            .then(() => {
                // 로컬 스트림 추가
                if (state.localStream) {
                    state.localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, state.localStream);
                    });
                }

                // Answer SDP 생성
                return peerConnection.createAnswer();
            })
            .then(answer => peerConnection.setLocalDescription(answer))
            .then(() => {
                // Answer SDP 전송
                sendMessage({
                    from: state.username,
                    empNum: state.empNum,
                    deptName: state.deptName,
                    type: 'answer',
                    payload: peerConnection.localDescription,
                    roomId: state.roomId,
                    to: username
                });
            })
            .catch(error => console.error('Answer 생성 오류:', error));
    }

    // Answer SDP 처리 함수
    function handleAnswer(username, answer) {
        if (username === state.username) return; // 자기 자신이면 무시

        console.log(`${username}로부터 Answer를 받았습니다.`);

        const pcWrapper = state.peerConnections[username];
        if (pcWrapper) {
            pcWrapper.setRemoteDescription(answer)
                .catch(error => {
                    console.error('원격 SDP 설정 오류:', error);

                    // 연결 재시도 (선택적)
                    if (!state.connectionRetries[username]) {
                        state.connectionRetries[username] = 0;
                    }

                    if (state.connectionRetries[username] < state.maxConnectionRetries) {
                        state.connectionRetries[username]++;
                        console.log(`${username}와의 연결 재시도 (${state.connectionRetries[username]}/${state.maxConnectionRetries})...`);

                        // PeerConnection 다시 생성 및 Offer 전송
                        setTimeout(() => {
                            cleanupPeerConnection(username);
                            handleNewUser(username, state.participantsMap.get(username)?.empNum, state.participantsMap.get(username)?.deptName);
                        }, 1000);
                    }
                });
        } else {
            console.warn(`${username}와의 연결을 찾을 수 없습니다.`);
        }
    }

    // ICE 후보 처리 함수
    function handleIceCandidate(username, candidate) {
        if (username === state.username) return; // 자기 자신이면 무시

        console.log(`${username}로부터 ICE 후보를 받았습니다.`);

        const pcWrapper = state.peerConnections[username];
        if (pcWrapper) {
            pcWrapper.addIceCandidate(candidate)
                .then(() => console.log(`${username}의 ICE 후보 추가 성공`))
                .catch(err => console.error(`${username}의 ICE 후보 추가 오류:`, err));
        } else {
            console.warn(`${username}와의 연결이 없습니다. ICE 후보 무시`);
        }
    }

    // 사용자 퇴장 처리 함수
    function handleUserLeft(username, empNum) {
        if (!username && !empNum) {
            console.warn('유효하지 않은 사용자 퇴장 메시지');
            return;
        }

        // empNum으로 참가자 조회 (username이 undefined일 때 대비)
        let targetUsername = username;
        if (empNum && !targetUsername) {
            const participant = state.participantsMap.get(empNum);
            if (participant) {
                targetUsername = participant.name || '알 수 없는 사용자';
            }
        }

        if (targetUsername) {
            // 참가자 목록에서 제거
            removeParticipant(targetUsername);

            // 비디오 요소 제거
            const videoElement = document.getElementById(`video-${targetUsername}`);
            if (videoElement) {
                const videoBox = videoElement.closest('.video-box');
                if (videoBox) {
                    videoBox.remove();
                } else {
                    videoElement.remove();
                }
            }

            // PeerConnection 정리
            cleanupPeerConnection(targetUsername);
        }

        // empNum으로도 참가자 맵에서 제거
        if (empNum) {
            state.participantsMap.delete(empNum);
        }

        // 비디오 레이아웃 재조정
        rearrangeVideoLayout();
    }

    // 연결 상태 변경 처리
    function handleConnectionStateChange(username, connectionState) {
        console.log(`${username}와의 연결 상태: ${connectionState}`);

        // 상태에 따라 다른 처리
        switch (connectionState) {
            case 'connected':
                updateParticipantStatus(username, true);
                break;

            case 'disconnected':
            case 'failed':
                updateParticipantStatus(username, false);

                // 최대 재시도 횟수 이내면 다시 연결 시도
                if (!state.connectionRetries[username]) {
                    state.connectionRetries[username] = 0;
                }

                if (state.connectionRetries[username] < state.maxConnectionRetries) {
                    state.connectionRetries[username]++;
                    console.log(`${username}와의 연결 재시도 (${state.connectionRetries[username]}/${state.maxConnectionRetries})`);

                    // 기존 연결 종료
                    cleanupPeerConnection(username);

                    // 서버에서 해당 사용자가 여전히 활성 상태인지 확인
                    fetch(`/api/videoconf/participants?roomId=${state.roomId}`)
                        .then(response => response.json())
                        .then(participants => {
                            const isParticipantStillActive = participants.some(p =>
                                p.name === username || (p.empNum && state.participantsMap.get(p.empNum)?.name === username)
                            );

                            if (isParticipantStillActive) {
                                // 다시 연결 시도
                                setTimeout(() => {
                                    const participant = participants.find(p => p.name === username);
                                    if (participant) {
                                        handleNewUser(username, participant.empNum, participant.deptName);
                                    }
                                }, 1000);
                            } else {
                                // 참가자가 이미 나갔으면 연결 정리
                                cleanupPeerConnection(username);
                                removeParticipant(username);
                            }
                        })
                        .catch(error => {
                            console.error("참가자 확인 오류:", error);
                        });
                } else {
                    console.warn(`${username}와의 최대 재연결 시도 횟수 초과`);
                    cleanupPeerConnection(username);
                }
                break;

            case 'closed':
                // 의도적으로 닫은 연결
                updateParticipantStatus(username, false);
                break;
        }
    }

    // 연결 정리 함수
    function cleanupPeerConnection(username) {
        const pcWrapper = state.peerConnections[username];
        if (pcWrapper && pcWrapper.connection) {
            try {
                pcWrapper.connection.close();
            } catch (e) {
                console.warn(`${username}와의 연결 종료 중 오류:`, e);
            }
            delete state.peerConnections[username];
        }
    }

    // PeerConnection 생성 함수
    function createPeerConnection(username) {
        try {
            const peerConnection = new RTCPeerConnection(peerConnectionConfig);

            // ICE 후보 큐 관리를 위한 변수들
            const iceCandidatesQueue = [];

            // PeerConnection 참조 저장
            const pcWrapper = {
                connection: peerConnection,
                iceCandidatesQueue: iceCandidatesQueue,
                isRemoteDescriptionSet: false,

                // 원격 설명 설정 메서드
                setRemoteDescription: async function(desc) {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(desc));
                        this.isRemoteDescriptionSet = true;

                        // 큐에 있는 ICE 후보들 처리
                        console.log(`${username}에 대한 큐에 저장된 ICE 후보 ${iceCandidatesQueue.length}개 처리 중`);
                        while (iceCandidatesQueue.length > 0) {
                            const candidate = iceCandidatesQueue.shift();
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                                .catch(error => console.error('큐의 ICE 후보 추가 오류:', error));
                        }
                        return true;
                    } catch (error) {
                        console.error('원격 설명 설정 오류:', error);
                        return false;
                    }
                },

                // ICE 후보 추가 메서드
                addIceCandidate: async function(candidate) {
                    if (this.isRemoteDescriptionSet) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            return true;
                        } catch (error) {
                            console.error('ICE 후보 추가 오류:', error);
                            return false;
                        }
                    } else {
                        // 원격 설명이 설정되기 전이면 큐에 저장
                        console.log(`${username}에 대한 ICE 후보를 큐에 저장 (원격 설명 대기 중)`);
                        iceCandidatesQueue.push(candidate);
                        return true;
                    }
                }
            };

            state.peerConnections[username] = pcWrapper;

            // ICE 후보 이벤트 처리
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage({
                        from: state.username,
                        empNum: state.empNum,
                        deptName: state.deptName,
                        type: 'ice',
                        payload: event.candidate,
                        roomId: state.roomId,
                        to: username
                    });
                }
            };

            // 원격 스트림 추가 이벤트 처리
            peerConnection.ontrack = event => {
                console.log(`${username}로부터 트랙 수신:`, event.track.kind);

                // 이미 비디오 요소가 있는지 확인
                const existingVideo = document.getElementById(`video-${username}`);

                if (!existingVideo && event.streams && event.streams[0]) {
                    addVideoStream(username, event.streams[0], false);
                    // 참가자 상태 업데이트
                    updateParticipantStatus(username, true);
                }
            };

            // 연결 상태 변경 감지
            peerConnection.onconnectionstatechange = () => {
                handleConnectionStateChange(username, peerConnection.connectionState);
            };

            // ICE 연결 상태 모니터링
            peerConnection.oniceconnectionstatechange = () => {
                console.log(`${username}와의 ICE 연결 상태 변경: ${peerConnection.iceConnectionState}`);

                // ICE 상태가 실패하면 재시도
                if (peerConnection.iceConnectionState === 'failed') {
                    console.warn(`${username}와의 ICE 연결 실패, 재시도 중...`);
                    // ICE 재협상 시도
                    peerConnection.restartIce();
                }
            };

            return pcWrapper;
        } catch (error) {
            console.error(`${username}와의 PeerConnection 생성 오류:`, error);
            return null;
        }
    }

    // 비디오 스트림 추가 함수
    function addVideoStream(username, stream, isLocal) {
        try {
            // 이미 있는 비디오 요소인지 확인
            const existingVideo = document.getElementById(`video-${username}`);
            if (existingVideo) {
                // 이미 존재하는 경우 스트림만 교체
                existingVideo.srcObject = stream;
                return;
            }

            const videoBox = document.createElement('div');
            videoBox.className = 'video-box';
            if (isLocal) {
                videoBox.classList.add('local-video');
            }

            const video = document.createElement('video');
            video.srcObject = stream;
            video.id = `video-${username}`;
            video.autoplay = true;
            video.playsInline = true;

            if (isLocal) {
                video.muted = true; // 자기 소리는 음소거
            }

            // 비디오 로딩 오류 처리
            video.onerror = (e) => {
                console.error(`비디오 로딩 오류 (${username}):`, e);
                const statusDiv = document.createElement('div');
                statusDiv.className = 'video-status';
                statusDiv.textContent = '비디오를 로드할 수 없습니다';
                videoBox.appendChild(statusDiv);
            };

            // 비디오 상태 메시지
            const statusDiv = document.createElement('div');
            statusDiv.className = 'video-status';
            statusDiv.textContent = '비디오 연결 중...';
            videoBox.appendChild(statusDiv);

            // 비디오 로딩 완료 시 상태 메시지 제거
            video.onloadedmetadata = () => {
                videoBox.querySelector('.video-status')?.remove();
            };

            const userName = document.createElement('div');
            userName.className = 'user-name';
            userName.textContent = username + (isLocal ? ' (나)' : '');

            videoBox.appendChild(video);
            videoBox.appendChild(userName);
            videoContainer.appendChild(videoBox);

            // 비디오 스트림 트랙 종료 모니터링
            stream.getTracks().forEach(track => {
                track.onended = () => {
                    console.log(`${username}의 ${track.kind} 트랙이 종료되었습니다.`);

                    // 비디오 트랙인 경우 상태 표시
                    if (track.kind === 'video') {
                        const videoStatus = document.createElement('div');
                        videoStatus.className = 'video-status';
                        videoStatus.textContent = '카메라가 중지되었습니다';

                        // 기존 상태 메시지 제거
                        videoBox.querySelector('.video-status')?.remove();

                        videoBox.appendChild(videoStatus);
                    }
                };
            });

            // 화면 재배치
            rearrangeVideoLayout();
        } catch (error) {
            console.error(`비디오 스트림 추가 오류 (${username}):`, error);
        }
    }

    // 비디오 레이아웃 재배치 함수
    function rearrangeVideoLayout() {
        const videoCount = videoContainer.children.length;

        // 비디오 수에 따라 그리드 레이아웃 조정
        if (videoCount <= 1) {
            videoContainer.style.gridTemplateColumns = '1fr';
        } else if (videoCount === 2) {
            videoContainer.style.gridTemplateColumns = '1fr 1fr';
        } else if (videoCount <= 4) {
            videoContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
        } else {
            videoContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
        }
    }

    // 참가자 목록에 추가
    function addParticipant(username, isLocal, deptName = '') {
        state.participants[username] = {
            online: true,
            isLocal: isLocal,
            deptName: deptName
        };

        const existingParticipant = document.getElementById(`participant-${username}`);
        if (existingParticipant) {
            return; // 이미 있으면 추가하지 않음
        }

        const li = document.createElement('li');
        li.id = `participant-${username}`;

        const status = document.createElement('div');
        status.className = 'status';
        status.title = '접속 중';

        const nameInfo = document.createElement('div');
        nameInfo.style.display = 'flex';
        nameInfo.style.flexDirection = 'column';

        const name = document.createElement('span');
        name.textContent = username + (isLocal ? ' (나)' : '');
        name.style.fontWeight = 'bold';

        const dept = document.createElement('span');
        dept.textContent = deptName || '';
        dept.style.fontSize = '0.8rem';
        dept.style.color = '#6c757d';

        nameInfo.appendChild(name);
        if (deptName) {
            nameInfo.appendChild(dept);
        }

        li.appendChild(status);
        li.appendChild(nameInfo);
        participantsList.appendChild(li);
    }

    // 참가자 목록에서 제거
    function removeParticipant(username) {
        delete state.participants[username];

        const li = document.getElementById(`participant-${username}`);
        if (li) {
            li.remove();
        }
    }

    // 참가자 상태 업데이트
    function updateParticipantStatus(username, isOnline) {
        if (state.participants[username]) {
            state.participants[username].online = isOnline;

            const statusElement = document.querySelector(`#participant-${username} .status`);
            if (statusElement) {
                if (isOnline) {
                    statusElement.style.backgroundColor = 'var(--success-color)';
                    statusElement.classList.remove('offline');
                    statusElement.title = '접속 중';
                } else {
                    statusElement.style.backgroundColor = 'var(--secondary-color)';
                    statusElement.classList.add('offline');
                    statusElement.title = '연결 끊김';
                }
            }
        }
    }

    // 오디오 토글 함수
    function toggleAudio() {
        state.isMuted = !state.isMuted;

        state.localStream.getAudioTracks().forEach(track => {
            track.enabled = !state.isMuted;
        });

        if (state.isMuted) {
            toggleAudioBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
            toggleAudioBtn.classList.add('mute');
            showToast('info', '마이크', '마이크가 음소거되었습니다.');
        } else {
            toggleAudioBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            toggleAudioBtn.classList.remove('mute');
            showToast('info', '마이크', '마이크가 활성화되었습니다.');
        }
    }

    // 비디오 토글 함수
    function toggleVideo() {
        state.isVideoOff = !state.isVideoOff;

        state.localStream.getVideoTracks().forEach(track => {
            track.enabled = !state.isVideoOff;
        });

        if (state.isVideoOff) {
            toggleVideoBtn.innerHTML = '<i class="fas fa-video-slash"></i>';
            toggleVideoBtn.classList.add('mute');
            showToast('info', '카메라', '카메라가 중지되었습니다.');
        } else {
            toggleVideoBtn.innerHTML = '<i class="fas fa-video"></i>';
            toggleVideoBtn.classList.remove('mute');
            showToast('info', '카메라', '카메라가 활성화되었습니다.');
        }
    }

    // 화면 공유 토글 함수
    async function toggleScreenSharing() {
        try {
            if (!state.isScreenSharing) {
                // 화면 공유 시작
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true
                });

                state.screenStream = screenStream;

                // 기존 비디오 트랙 대체
                const videoTrack = screenStream.getVideoTracks()[0];

                // 모든 피어 연결에 새 트랙 추가
                Object.values(state.peerConnections).forEach(pcWrapper => {
                    if (pcWrapper.connection) {
                        const senders = pcWrapper.connection.getSenders();
                        const videoSender = senders.find(sender =>
                            sender.track && sender.track.kind === 'video'
                        );

                        if (videoSender) {
                            videoSender.replaceTrack(videoTrack);
                        }
                    }
                });

                // 로컬 비디오 업데이트
                const localVideo = document.getElementById(`video-${state.username}`);
                if (localVideo) {
                    localVideo.srcObject = screenStream;
                }

                // 화면 공유 종료 처리
                videoTrack.onended = () => {
                    stopScreenSharing();
                };

                shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i>';
                shareScreenBtn.classList.add('mute');
                state.isScreenSharing = true;
                showToast('success', '화면 공유', '화면 공유가 시작되었습니다.');
            } else {
                // 화면 공유 중지
                stopScreenSharing();
            }
        } catch (error) {
            console.error('화면 공유 오류:', error);
            showToast('error', '화면 공유 오류', '화면 공유를 시작할 수 없습니다. 권한을 확인해주세요.');
        }
    }

    // 화면 공유 중지 함수
    function stopScreenSharing() {
        if (state.screenStream) {
            state.screenStream.getTracks().forEach(track => track.stop());
            state.screenStream = null;
        }

        // 원래 비디오 트랙으로 복원
        const videoTrack = state.localStream.getVideoTracks()[0];

        if (videoTrack) {
            // 모든 피어 연결 업데이트
            Object.values(state.peerConnections).forEach(pcWrapper => {
                if (pcWrapper.connection) {
                    const senders = pcWrapper.connection.getSenders();
                    const videoSender = senders.find(sender =>
                        sender.track && sender.track.kind === 'video'
                    );

                    if (videoSender) {
                        videoSender.replaceTrack(videoTrack);
                    }
                }
            });

            // 로컬 비디오 업데이트
            const localVideo = document.getElementById(`video-${state.username}`);
            if (localVideo) {
                localVideo.srcObject = state.localStream;
            }
        }

        shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i>';
        shareScreenBtn.classList.remove('mute');
        state.isScreenSharing = false;
        showToast('info', '화면 공유', '화면 공유가 중지되었습니다.');
    }

    // 회의 나가기 함수
    function leaveRoom() {
        // 이미 나가기 처리 중이면 무시
        if (state.isLeaving) {
            console.log('이미 방 나가기 처리 중입니다.');
            return;
        }

        state.isLeaving = true;
        showLoading();

        // 하트비트 중지
        stopHeartbeat();

        // 세션 스토리지에서 방 정보 제거
        sessionStorage.removeItem('roomId');
        sessionStorage.removeItem('roomName');
        sessionStorage.removeItem('roomPassword');

        // 서버에 방 나가기 API 호출
        fetch(`/api/videoconf/leave-room?roomId=${state.roomId}&empNum=${state.empNum}`, {
            method: 'POST'
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('방 나가기에 실패했습니다.');
                }
                return response.text();
            })
            .then(result => {
                console.log('방 나가기 성공:', result);

                // 방 나가기 메시지 전송
                if (stompClient && stompClient.connected) {
                    sendMessage({
                        from: state.username,
                        empNum: state.empNum,
                        type: 'leave',
                        roomId: state.roomId
                    });
                }

                // WebSocket 연결 종료 (의도적)
                disconnectWebSocket();

                // 리소스 정리
                clearResources();

                // 로비 페이지로 이동
                window.location.href = '/videoconf-lobby';
            })
            .catch(error => {
                console.error('방 나가기 API 오류:', error);
                showToast('error', '오류 발생', '방 나가기 중 오류가 발생했습니다.');

                // 오류 발생해도 로비로 이동
                window.location.href = '/videoconf-lobby';
            })
            .finally(() => {
                hideLoading();
                state.isLeaving = false;
            });
    }

    // 리소스 정리 함수
    function clearResources() {
        // 모든 미디어 트랙 중지
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => track.stop());
        }

        if (state.screenStream) {
            state.screenStream.getTracks().forEach(track => track.stop());
        }

        // 모든 PeerConnection 종료
        Object.values(state.peerConnections).forEach(pcWrapper => {
            if (pcWrapper.connection) {
                pcWrapper.connection.close();
            }
        });

        // WebSocket 연결 종료
        disconnectWebSocket();

        // 상태 초기화
        state.localStream = null;
        state.screenStream = null;
        state.peerConnections = {};
        state.participants = {};
        state.participantsMap.clear();
        state.isMuted = false;
        state.isVideoOff = false;
        state.isScreenSharing = false;
    }
</script>
<!-- 헤더 관련 스크립트 포함 -->
<div th:replace="fragments/header :: headerScripts"></div>
</body>
</html>